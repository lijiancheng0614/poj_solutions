# Bugs Integrated, Inc.

## 题目

给定 n * m 的 01 矩阵，其中有 k 个 1

求最多能找出多少个不重叠的 2 * 3 或 3 * 2 的全 0 子矩阵


## 方法

动态规划（状态压缩）

每找到一个全 0 子矩阵则把子矩阵内所有元素标记为 1

设 f[i][k1, k2, ..., km] 表示前 i 行状态为 k1, k2, ..., km 的答案

状态 kj 有 3 种：

0: (i, j) 为 0, (i - 1, j) 为 0

1: (i, j) 为 0, (i - 1, j) 为 1

2: (i, j) 为 1

状态转移有三种情况：

若 (i + 1, j) 为 1，则 kj' = 2, 若 kj = 2，则 kj' = 1，否则 kj' = 0

1. 不放子矩阵，则 f[i + 1][k1', k2', ..., km'] = max{f[i][k1, k2, ..., km]}

2. 放 3 * 2 子矩阵 [(i - 1, j), (i + 1, j + 1)]，即 kj = k[j + 1] = kj' = k'[j + 1] = 0，则 f[i + 1][k1', k2', ..., km'] = max{f[i][k1, k2, ..., km] + 1}

3. 放 2 * 3 子矩阵 [(i, j), (i + 1, j + 2)]，即 kj' = k'[j + 1] = k'[j + 2] = 0，则 f[i + 1][k1', k2', ..., km'] = max{f[i][k1, k2, ..., km] + 1}

答案为 max{f[n][...]}

把 k1, k2, ..., km 压缩成一个三进制整数和第一维使用滚动数组可节省空间
